/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Verifies and deserializes a chunk by checking its content hash matches the provided name.
 *
 * # Arguments
 *
 * * `name` - The expected XorName hash of the chunk content
 * * `bytes` - The serialized chunk content to verify
 *
 * # Returns
 *
 * * `Result<EncryptedChunk>` - The deserialized chunk if verification succeeds
 * * `Error` - If the content hash doesn't match or deserialization fails
 */
export declare function verifyChunk(name: XorName, bytes: Uint8Array): EncryptedChunk
/** The minimum size (before compression) of an individual chunk of a file, defined as 1B. */
export const MIN_CHUNK_SIZE: bigint
/** The maximum size (before compression) of an individual chunk of a file, defaulting as 1MiB. */
export const MAX_CHUNK_SIZE: bigint
/** Controls the compression-speed vs compression-density tradeoffs. The higher the quality, the slower the compression. Range is 0 to 11. */
export const COMPRESSION_QUALITY: number
/** The minimum size (before compression) of data to be self-encrypted, defined as 3B. */
export const MIN_ENCRYPTABLE_BYTES: bigint
/**
 * Encrypt raw data into chunks.
 *
 * This function takes raw data, splits it into chunks, encrypts them,
 * and returns a DataMap and list of encrypted chunks.
 */
export declare function encrypt(data: Uint8Array): EncryptResult
/** Decrypts data using chunks retrieved from any storage backend via the provided retrieval function. */
export declare function decrypt(dataMap: DataMap, chunks: Array<EncryptedChunk>): Uint8Array
/**
 * Decrypts data using a DataMap and stored chunks.
 *
 * This function retrieves encrypted chunks using the provided callback,
 * decrypts them according to the DataMap, and writes the result to a file.
 */
export declare function decryptFromStorage(dataMap: DataMap, outputFile: string, getChunk: (...args: any[]) => any): void
/**
 * Decrypts data from storage in a streaming fashion using parallel chunk retrieval.
 *
 * This function retrieves the encrypted chunks in parallel using the provided `getChunkParallel` function,
 * decrypts them, and writes the decrypted data directly to the specified output file path.
 */
export declare function streamingDecryptFromStorage(dataMap: DataMap, outputFile: string, getChunkParallel: (xorNames: XorName[]) => Uint8Array): void
export declare function streamingEncryptFromFile(filePath: string, chunkStore: (xorName: XorName, bytes: Uint8Array) => undefined): DataMap
/**
 * Encrypt a file and store its chunks.
 *
 * This function reads a file, splits it into chunks, encrypts them,
 * and stores them in the specified directory.
 */
export declare function encryptFromFile(inputFile: string, outputDir: string): EncryptFromFileResult
/**
 * A 256-bit number, viewed as a point in XOR space.
 *
 * This wraps an array of 32 bytes, i. e. a number between 0 and 2<sup>256</sup> - 1.
 *
 * XOR space is the space of these numbers, with the [XOR metric][1] as a notion of distance,
 * i. e. the points with IDs `x` and `y` are considered to have distance `x xor y`.
 *
 * [1]: https://en.wikipedia.org/wiki/Kademlia#System_details
 */
export declare class XorName {
  /** Create a new XorName from content bytes. */
  static fromContent(content: Uint8Array): XorName
  /** Get the underlying bytes of the XorName. */
  asBytes(): Uint8Array
  toHex(): string
  static fromHex(hex: string): XorName
}
/**
 * This is - in effect - a partial decryption key for an encrypted chunk of data.
 *
 * It holds pre- and post-encryption hashes as well as the original
 * (pre-compression) size for a given chunk.
 * This information is required for successful recovery of a chunk, as well as for the
 * encryption/decryption of it's two immediate successors, modulo the number of chunks in the
 * corresponding DataMap.
 */
export declare class ChunkInfo {
  constructor(index: number, dstHash: XorName, srcHash: XorName, srcSize: number)
  get index(): number
  get dstHash(): XorName
  get srcHash(): XorName
  get srcSize(): number
}
/**
 * Holds the information that is required to recover the content of the encrypted file.
 * This is held as a vector of `ChunkInfo`, i.e. a list of the file's chunk hashes.
 * Only files larger than 3072 bytes (3 * MIN_CHUNK_SIZE) can be self-encrypted.
 * Smaller files will have to be batched together.
 */
export declare class DataMap {
  /**
   * A new instance from a vec of partial keys.
   *
   * Sorts on instantiation.
   * The algorithm requires this to be a sorted list to allow get_pad_iv_key to obtain the
   * correct pre-encryption hashes for decryption/encryption.
   */
  static new(keys: Array<ChunkInfo>): DataMap
  /** Creates a new DataMap with a specified child value */
  static withChild(keys: Array<ChunkInfo>, child: bigint): DataMap
  /** Original (pre-encryption) size of the file. */
  originalFileSize(): bigint
  /** Returns the list of chunks pre and post encryption hashes if present. */
  infos(): Array<ChunkInfo>
  /** Returns the child value if set */
  child(): bigint | null
  /** Returns the number of chunks in the DataMap */
  len(): bigint
  /** Returns true if this DataMap has a child value */
  isChild(): boolean
}
/**
 * A JavaScript wrapper for the EncryptedChunk struct.
 *
 * EncryptedChunk represents an encrypted piece of data along with its
 * metadata like size and hash. Chunks are stored separately and
 * referenced by the DataMap.
 */
export declare class EncryptedChunk {
  /** Get the size of the original content before encryption. */
  contentSize(): number
  /** Get the hash of the encrypted chunk. */
  hash(): Uint8Array
  /** Get the content of the encrypted chunk. */
  content(): Uint8Array
}
/** Result type for the encrypt_from_file function */
export declare class EncryptFromFileResult {
  get dataMap(): DataMap
  get chunkNames(): Array<string>
}
/** Result type for the encrypt function */
export declare class EncryptResult {
  get dataMap(): DataMap
  get chunks(): Array<EncryptedChunk>
}
